Graph Traversals
================

1. From the user's perspective, the program works by first allowing them to input the number of edges they which to place, followed by the specific vertices that form each edge. Next, the user can input the number of paths they wish to check for, and can then input that number of specific path combinations. Right after the user inputs each path, the program will output whether or not this path exists. Once the user has inputted all the paths they are looking for and have received the corresponding output, the user can input another number of edges, and begin this process over again. The user can also choose to quit at this point by inputting ctrl+d.

2. Internally, my program works by representing the graph as an adjacency matrix, which is formed by a vector of vectors. In main, a while loop is used, and the condition checks whether the number of edges has been inputted by the user. If it has not, and the user enters ctrl+D instead, the while loop will break and the program will end. Next, for each set of edges and paths, a vector of vectors is formed. Each element in this vector of vectors is of type node, meaning it has two boolean properties: path and visited. Path tracks whether a certain path exists, and visited tracks whether a path has already been checked or not. Both path and visited are initialized to false, and the matrix is set to double the size of edges, since this is the largest possible size of the matrix. After, I have a for loop that takes each pair of vertices and sets the matrix location corresponding to their location as having a true path variable. Next, the user inputs the number of paths they wish to check for, and a for loop is run through for each pair of vertices. The checkPath function is called on the two vertices. I used a depth first traversal, since I recurse as far as possible for each neighboring node before moving on to the next neighbor. This function first checks if there is a direct path between the two, meaning that the vector location for these two vertices has a path variable that is set to 1. If this is not the case, then a for loop checks all the possible paths from the start vertex. If a path exists between the two and the path has not been visited yet, then visited is set to true and the function is called recursively with i now as the start variable. This will continue until the first if statement is true and the path exists, upon which true is returned. Otherwise, the for loop is completed with ever finding a path, and false is returned. If true is returned, a message is output letting the user know the path exists, and if false is returned, a message is output letting the user know the path does not exist. n is incremented, and then the user can input another batch of edges and paths.

3. I evaluated that my program was correct by piping the input into the executable and checking the output against the output given to us. Once the output I received matched the expected output, I knew my program worked correctly.


